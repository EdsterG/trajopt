from __future__ import print_function
import re, StringIO
def make_fwd_header(fnames, outfile, namespaces = []):
    classes = []
    for header in fnames:
        
        with open(header, "r") as fh:
            classes.extend(find_classes(fh.read()))
    with open(outfile, "w") as fh:
        print("// autogenerated forward declaration header", file=fh)
        print("#pragma once", file=fh)
        print("#include <boost/shared_ptr.hpp>", file=fh)
        for ns in namespaces:
            print("namespace %s {"%ns, file=fh)
        for name in classes:
            d = dict(name=name)
            print("class %(name)s;"%d, file=fh)
            print("typedef boost::shared_ptr<%(name)s> %(name)sPtr;"%d, file=fh)
        print("}"*len(namespaces), file=fh)

def find_classes(text):
    """
    find line that contains a top-level open brace
    then look for class { in that line
    """
    nest_level = 0
    brace_re = re.compile("[\{\}]")
    classname_re = "[\w\<\>\:]+"
    class_re = re.compile(
        "(?:class|struct)\s*(\w+)\s*(?:\:\s*public\s*" 
        + classname_re  + "(?:,\s*public\s*" + classname_re + ")*)?\s*\{")
    
    classes = []
    lines = text.split("\n")
    for (i,line) in enumerate(lines):
        if True:#nest_level == 0 and (i==0 or "template" not in lines[i-1]):            
            classes.extend(class_re.findall(line))
        
        braces = brace_re.findall(line)
        for brace in braces:
            if brace == "{": nest_level += 1
            elif brace == "}": nest_level -= 1
            
    return classes
